<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>@testing-library</title>
    <link rel="stylesheet" href="/theme/reset.css" />
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="/dist/theme/goblindegook.css" id="theme" />
    <link
      rel="stylesheet"
      href="/node_modules/reveal.js/plugin/highlight/monokai.css"
      id="highlight-theme"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>@testing-library</h1>
          <p><em>Or, how I learned to stop worrying about the DOM.</em></p>
          <hr />
          <p>LuxembourgJS ¬∑ November 4, 2020</p>
        </section>

        <section>
          <h2>Lu√≠s Rodrigues</h2>
          <p><a href="https://goblindegook.com">goblindegook.com</a></p>
          <p><a href="https://twitter.com/goblindegook">@goblindegook</a></p>
        </section>

        <section>
          <p>
            Testing the frontend<br />
            with confidence.
          </p>

          <aside class="notes">
            The point of testing is to be able to develop, debug, and deploy
            with confidence. Don't go chasing metrics or prescribed formulas.
            Ask, "Does this test give me confidence?"
          </aside>
        </section>

        <section>
          <h3>Browser Tests</h3>
          <ul class="emoji">
            <li data-emoji="‚ùå">Convenient</li>
            <li data-emoji="‚ùå">Fast</li>
            <li data-emoji="‚ùå">Maintainable</li>
            <li data-emoji="‚ùå">Robust</li>
          </ul>

          <aside class="notes">
            Tests are complicated and hard to setup, slow AF, (Cu)cumbersome
            changes, tests break all the time.
          </aside>
        </section>

        <section>
          <h3>React + Enzyme</h3>
          <ul class="emoji">
            <li data-emoji="‚úÖ">Convenient</li>
            <li data-emoji="‚úÖ">Fast</li>
            <li data-emoji="ü§∑‚Äç‚ôÄÔ∏è">Maintainable</li>
            <li data-emoji="ü§∑‚Äç‚ôÄÔ∏è">Robust</li>
          </ul>
        </section>

        <section>
          <p>Shallow rendering.</p>
        </section>

        <section>
          TODO: Redo diagram to explain shallow rendering

          <aside class="notes">
            Allows ‚Äòtesting a component as a unit‚Äô, and ensures tests aren‚Äôt
            indirectly asserting on behavior of child components.
          </aside>
        </section>

        <section>
          <h3>Too easy to test implementation details</h3>

          <ul>
            <li>Shallow rendering.</li>
            <li>Select by component name or props.</li>
            <li>Component instance state inspection.</li>
          </ul>

          <aside class="notes">
            Testing implementation details limits your ability to refactor.
            Refactoring is one of the most important approaches to tackling tech
            debt. You don‚Äôt want to have your hands tied here. If tests are
            constantly breaking for no good reason, you‚Äôll stop testing. Tests
            with shallow rendering are prone to break when components or
            component structure change, even if presentation and behaviour
            remains the same.
          </aside>
        </section>

        <section>
          <ul class="emoji">
            <li data-emoji="üíî">Testing via the browser.</li>
            <li data-emoji="üíî">Testing implementation details.</li>
          </ul>

          <aside class="notes">So what should we test?</aside>
        </section>

        <section data-background-image="/assets/testing-library/pyramid.jpg">
          <aside class="notes">
            This wouldn't be a proper talk about tests if it didn't have the
            pyramid.
          </aside>
        </section>

        <section
          data-background-image="/assets/testing-library/pyramid.jpg"
          data-background-opacity="0.2"
        >
          <p>Slower</p>
          <p>‚Üï</p>
          <p>Faster</p>
        </section>

        <section
          data-background-image="/assets/testing-library/pyramid.jpg"
          data-background-opacity="0.2"
        >
          <p>More Expensive</p>
          <p>‚Üï</p>
          <p>Cheaper</p>
        </section>

        <section
          data-background-image="/assets/testing-library/pyramid.jpg"
          data-background-opacity="0.2"
        >
          <p>Big Picture</p>
          <p>‚Üï</p>
          <p>Detail</p>
        </section>

        <section
          data-background-image="/assets/testing-library/pyramid.jpg"
          data-background-opacity="0.2"
        >
          <p>Cooperation</p>
          <p>‚Üï</p>
          <p>Single Responsibility</p>
        </section>

        <section>
          <h2>The messy middle</h2>

          <aside class="notes">
            The definitions of ‚Äòunit test‚Äô and ‚Äòintegration test‚Äô are a bit
            wishy-washy. And is it 'integration', 'integrated', 'service',
            or...?
          </aside>
        </section>

        <section>
          <blockquote>
            <p>‚ÄúWrite tests. Not too many. Mostly integration.‚Äù</p>
            <cite>Guillermo Rauch</cite>
          </blockquote>
        </section>

        <section>
          <blockquote>
            <p>‚ÄúIntegrated tests are a scam.‚Äù</p>
            <cite>J.B. Rainsberger</cite>
          </blockquote>
        </section>

        <section>
          <p>A unit test must run in isolation.</p>

          <aside class="notes">
            Misconceptions slot neatly into Enzyme's antipatterns. Isolation
            does not mean mock everything else. It means the TEST ITSELF must be
            isolated. It should be able to run by itself, in a sequence of
            tests, or even in parallel.
          </aside>
        </section>

        <section>
          <p>A unit test must be fast.</p>
        </section>

        <section>
          <p>A unit test must focus on a ‚Äòsmall‚Äô part of the system.</p>

          <aside class="notes">
            "Small" does not mean "smallest". It's not about testing every
            individual function or class of the system.
          </aside>
        </section>

        <section>
          <p>
            The <em>unit</em> is whatever makes sense,<br />
            tested at a level that makes sense.
          </p>

          <aside class="notes">
            A test is described by how it handles itself, not by the size or
            complexity of the component it's testing.
          </aside>
        </section>

        <section>
          <h3>Stuff I don‚Äôt care about when doing TDD:</h3>
          <ul>
            <li>What subcomponents I‚Äôm going to need.</li>
            <li>How they‚Äôre implemented.</li>
            <li>Who implements them.</li>
          </ul>

          <aside class="notes">
            Often subcombonents are a consequence of refactoring. Third party
            dependencies.
          </aside>
        </section>

        <section>
          <h2>Fake it till you break it</h2>
        </section>

        <section>
          <blockquote>
            <p>‚ÄúMocking is a code smell.‚Äù</p>
            <cite>Eric Elliot</cite>
          </blockquote>
        </section>

        <section>
          <p>
            When your tests are green<br />
            but the application is broken.
          </p>

          <aside class="notes">
            Shallow rendering/mocking is how you can have 100% test coverage
            with a broken application. You're missing the point of tests.
            Changing potentially untested subcomponents. Third-party components
            break but tests never exercise them.
          </aside>
        </section>

        <section>
          <p>
            You don‚Äôt need to test third-party code<br />
            but maybe you should.
          </p>

          <aside class="notes">
            You still need to ensure the application works. What‚Äôs the point of
            having all green unit tests if some untested component or
            integration breaks the application? Don‚Äôt fake or mock components
            unless you‚Äôre doing it to avoid a) shared state that breaks test
            isolation, b) slowness, c) setup complexity, or d) unpredictability.
          </aside>
        </section>

        <section>
          <h2><a href="https://testing-library.com">@testing-library</a></h2>
        </section>

        <section>
          <blockquote>
            <p>
              ‚ÄúThe more your tests resemble the way your software is used, the
              more confidence they can give you.‚Äù
            </p>
            <cite>Kent C. Dodds</cite>
          </blockquote>
        </section>

        <section>
          Provides a set of primitives that mimic user interaction.
        </section>

        <section>
          <h3>Less this</h3>
          <pre><code data-trim data-lang="js">
            $('div.login .btn-primary + a').click()
					</code></pre>
        </section>

        <section>
          <h3>More this</h3>
          <pre><code data-trim data-lang="js">
							fireEvent.click(getByText(/recover password/i))
					</code></pre>
        </section>

        <section>
          <table>
            <tr>
              <td style="text-align: right; vertical-align: middle">
                <p>
                  <code>get</code><br />
                  <code>getAll</code>
                </p>
                <p>
                  <code>query</code><br />
                  <code>queryAll</code>
                </p>
                <p>
                  <code>find</code><br />
                  <code>findAll</code>
                </p>
              </td>
              <td style="vertical-align: middle">+</td>
              <td style="vertical-align: middle">
                <p>
                  <code>ByText()</code><br />
                  <code>ByLabelText()</code><br />
                  <code>ByPlaceholderText()</code><br />
                  <code>ByAltText()</code><br />
                  <code>ByTitle()</code><br />
                  <code>ByDisplayValue()</code><br />
                  <code>ByRole()</code>
                </p>
              </td>
            </tr>
          </table>

          <aside class="notes">
            <p>Search by text or RegExp.</p>
            <p>No CSS selectors, you see what the user sees.</p>
            <p>Link or button? Doesn‚Äôt matter!</p>
          </aside>
        </section>

        <section>
          <h3>Escape hatch</h3>

          <p><code>getByTestId()</code></p>

          <aside class="notes">
            Last resort if all else fails. Does not overload other IDs or
            classes for testing.
          </aside>
        </section>

        <section>
          <pre><code data-trim data-noescape data-line-numbers="5-7|9">
						<script type="text/template">
							test('has a delete button', () => {
								const data = { id: '9999', name: 'Test entry.' }
								const handleDelete = jest.fn()

								const { getByText, findByText } = render(
									<Entry data={data} onDelete={handleDelete} />
								)

								const input = getByText(/Delete/i)
								expect(input.type).toBe('button')
							})
						</script>
					</code></pre>
        </section>

        <section>
          What you get back is DOM nodes.

          <aside class="notes">
            No wrappers around React components. Reimplement the component in
            Vue and you‚Äôll barely need to touch tests.
          </aside>
        </section>

        <section>
          <pre><code data-trim>
							fireEvent.click(getByText('Click me!'))
					</code></pre>
        </section>

        <section>
          <pre><code data-trim data-noescape data-line-numbers="4-6|8-9">
						<script type="text/template">
						test('deletes entry after animation', () => {
              const data = { id: '9999', name: 'Test entry.' }
              const handleDelete = jest.fn()
              const { getByText, findByText } = render(
                <Entry data={data} onDelete={handleDelete} />
              )

              fireEvent.click(getByText(/Delete/i))
              fireEvent.click(await findByText(/Confirm/i))

              expect(handleDelete).toHaveBeenCalledWith('9999')
						})
						</script>
					</code></pre>
        </section>

        <section>
          Encourages <em>not</em> testing implementation details.

          <aside class="notes">
            Beware the tradeoffs: Having to write many similar tests for all
            possible outputs. When one change breaks multiple tests.
          </aside>
        </section>

        <section>
          Promotes good accessibility practices.

          <aside class="notes">
            By not providing CSS node selectors, it encourages adoption of
            clear, unambiguous labels, titles and alt text.
          </aside>
        </section>

        <section>Simple and lightweight.</section>

        <section>
          <a href="https://testing-examples.com">testing-examples.com</a>
        </section>

        <section>
          <h3>Frameworks</h3>

          <ul>
            <li>Angular</li>
            <li>React</li>
            <li>React Native</li>
            <li>Preact</li>
            <li>Svelte</li>
            <li>Vue</li>
          </ul>
        </section>

        <section>
          <h3>Other testing tools</h3>

          <ul>
            <li>Cypress</li>
            <li>Puppeteer</li>
            <li>TestCafe</li>
          </ul>
        </section>

        <section>
          <ul class="emoji">
            <li data-emoji="‚ù§Ô∏è">Delightful API.</li>
            <li data-emoji="‚ù§Ô∏è">Discourages testing implementation details.</li>
            <li data-emoji="‚ù§Ô∏è">Promotes creating accessible components.</li>
          </ul>

          <aside class="notes">
            Not a silver bullet. Consider the tradeoffs. The further up the
            render tree you go, and the further up the pyramid you go, the more
            careful you‚Äôll have to be to avoid duplication, brittleness, and
            ambiguity.
          </aside>
        </section>

        <section>
          <p>That is all.</p>

          <h1>Thank you</h1>

          <p><a href="https://goblindegook.com">goblindegook.com</a></p>
          <p><a href="https://twitter.com/goblindegook">@goblindegook</a></p>
        </section>
      </div>
    </div>

    <script src="/node_modules/reveal.js/dist/reveal.js"></script>
    <script src="/node_modules/reveal.js/plugin/notes/notes.js"></script>
    <script src="/node_modules/reveal.js/plugin/highlight/highlight.js"></script>
    <script>
      Reveal.initialize({
        hash: true,
        plugins: [RevealHighlight, RevealNotes],
      })
    </script>
  </body>
</html>
