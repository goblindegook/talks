import { Head, Image, Notes } from 'mdx-deck'
import { Split, SplitRight, FullScreenCode } from 'mdx-deck/layouts'

export { theme } from './theme'

<Head>
  <title>More My Type</title>
</Head>

`undefined is not a function`

---

# More My Type

_React applications in TypeScript_

<br />

Tech Along · January 30, 2020

---

<SplitRight>
<Image width="50vw" src="./assets/more-my-type/asshole.jpg" />

## Luís Rodrigues

[goblindegook.com](https://goblindegook.com)  
[@goblindegook](https://twitter.com/goblindegook)
</SplitRight>

---

<Image src="./assets/more-my-type/equal-experts-logo.png" />

---

_Types to the rescue!_

---

## Types in React

PropTypes _vs_ Flow _vs_ TypeScript

---

## PropTypes

* `prop-types` on NPM.
* Runtime validation.
* React components only.

<Notes>
  <p>Remember to disable PropTypes in production because performance.</p>
</Notes>

---

```jsx
import React from 'react'
import PropTypes from 'prop-types'

function Hello (props) {
  return <h1>Hello, {props.name}</h1>
}

Hello.propTypes = {
  name: PropTypes.string.isRequired
}
```

---

## Flow

* Typechecking utility.
* Types stripped on compilation.
* Supports PropTypes.

---

```tsx
import React from 'react'

type HelloProps = {
  name: string
}

function Hello (props: HelloProps) {
  return <h1>Hello, {props.name}</h1>
}
```

---

## TypeScript

* Programming language.
* Compiles to JavaScript.
* Typechecks at compile time.

---

```tsx
import React from 'react'

type HelloProps = {
  name: string
}

function Hello (props: HelloProps) {
  return <h1>Hello, {props.name}</h1>
}
```

<Notes>
  It looks the same but I promise you Flow and TypeScript are different.
</Notes>

---

_Let's focus on TypeScript._

---

### All the ECMAScript features you know and love

<Split>
<div>

* Classes
* Modules
* Arrow functions
* Default parameters
* Rest parameters

</div>
<div>

* Destructuring
* Generators
* `async`/`await`
* Optional chaining
* Nullish coalescence

</div>
</Split>

<Notes>
  TypeScript is a superset of ECMAScript.
</Notes>

---

_JSX is supported too, of course (as TSX)._

---

## Just add types

* Basic: `boolean`, `number`, `string`, `Array`, tuples, `enum`, `any`
* `void`, `null`, `undefined`
* `never`
* `unknown`

---

### Nullable types

```tsx
function getYear(date?: Date) {
  return date.getFullYear() // Error
}

function getYear(date?: Date) {
  if (date != null) {
    return date.getFullYear() // OK
  }
}
```

---

### Read-only types

```tsx
function addItem(
  list: readonly string[],
  item: string
): readonly string[] {
  // OK:
  return list.concat(item)

  // Error:
  list.push(item)
  return list
}
```

---

### Generics

```tsx
function addItem<T>(
  list: readonly T[],
  item: T
): readonly T[] {
  return list.concat(item)
}
```

---

<Split>
<div>

### Interfaces

```tsx
interface Person {
  name: string
  age: number
}
```

</div>
<div>

### Type Aliases

```tsx
type Person = {
  name: string
  age: number
}
```

</div>
</Split>

---

Mostly the same effect, except:

* Interfaces have a name;
* Interfaces support circular definitions;
* Classes may implement interfaces;
* Interfaces cannot mixin multiple interfaces.

---

_When in doubt, use_ `interface`_._

---

### Class features

```ts
class Meetup implements Event {
  constructor (private name: string) {}

  greet() {
    return `Hello, ＄{this.name}!`
  }
}

const meetup = new Meetup('Hack Along')

meetup.name // Error
```

---

### Intersection types

```ts
interface Item {
  name: string
  sku: string
}

interface Perishable {
  expires: Date
}

type FoodItem = Item & Perishable
```

---

### Union types

```ts
interface Bird {
  kind: 'bird'
  fly()
  layEggs()
}

interface Fish {
  kind: 'fish'
  swim()
  layEggs()
}

type Pet = Bird | Fish
```

---

### Type guards

```ts
function isBird(pet: Pet): pet is Bird {
  return pet.kind === 'bird'
}

if (isBird(somePet)) {
  somePet.fly()
}
```

---

_Type-checking Redux actions with_ `typescript-fsa`_._

<Notes>
  Demo.
</Notes>

---

## Building

---

### Client side: Webpack

`ts-loader` or `awesome-typescript-loader`

<Notes>
  ATL adds compiler cache and typechecks in parallel with compilation.
</Notes>

---

### Client side: Rollup

TODO

---

### Server side: `tsc`

Just use the TypeScript compiler.

Develop in the Node environment with `ts-node`.

---

### Babel is not required

_(But as of 2019, you can also compile TypeScript with Babel.)_

---

_Many JavaScript modules don't come with types. Now what?_

---

## Definitely Typed

Install typings for third-party modules from the `@types` organization.

`npm install @types/react`

---

## Migrating JavaScript Applications

---

### Incremental Migration

* JavaScript compiles as TypeScript without changes;
* TypeScript without TypeScript: typechecking with JSDoc comments;
* Leverage your existing Babel setup;
* Begin with looser compiler settings, turn on stricter settings as you approach completion.

---

TODO: Demo JSDoc

---

### Automated migration

* Semi-automated tools (ReSharper by JetBrains).

---

## Recommendations

---

### Recommendation: `noImplicitAny`

When a value type can't be inferred, TypeScript assigns it the `any` type.

`any` defeats the purpose of having a type checker.

<Notes>
Compiler option.
</Notes>

---

### Recommendation: `strictNullChecks`

Disallowing `null` value assignment prevents an entire class of errors.

`null` and `undefined` can still be explicitly allowed.

<Notes>
Compiler option.
</Notes>

---

### ESLint

Performs static code analysis.

Customizable with reasonable defaults.

---

### Let type inference do its work

Don't bother typing local variable declarations unless you have to.

Always add types to function and method signatures instead.

---

### Prefer function overloading over union types

Overloading is more readable than type unions.

---

```ts
function length(value: string | any[]): number {
  return value.length
}

function length(value: string): number
function length(value: any[]): number {
  return value.length
}
```

---

## Pain Points

---

### Third-party modules missing type definitions

* Roll your own type definitions.
* Contribute back to Definitely Typed.
* Import modules with no type definition.

---

### Compilation time

* Incremental builds.
* `awesome-typescript-loader`.
* Optimised watch mode for tests.

---

### It's still JavaScript in the end

* No runtime typechecks.
* No performance boost from static types.

---

## Why bother?

* Catch common errors like type invariance or null values at compilation time or on the IDE itself.
* Refactoring super powers.
* No need to write tests where types are asserted.
* Function signatures act like documentation.
* Sweet, sweet code autocompletion.

---

That is all.

# Thank you

[goblindegook.com](https://goblindegook.com)  
[@goblindegook](https://twitter.com/goblindegook)
